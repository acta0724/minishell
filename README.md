# minishell

シンプルな Unix シェル実装です。
`minishell` を通じて、プロセス生成、ファイルディスクリプタ管理、構文解析、シグナル処理など、シェルの基本動作を学ぶことができます。



## 概要

`minishell` は、Bash の基本動作を模倣する小規模なシェルを C 言語で実装したプログラムです。
ユーザからのコマンド入力をトークンに分解し、構文解析を行い、環境変数の展開（`$VAR` や `$?`）を行った後、ビルトインコマンドまたは外部実行ファイルを子プロセスとして起動します。
学習目標としては、以下を含みます。

* コマンド行のトークン化とパース
* ビルトインコマンド（`cd`、`echo`、`export`、`unset`、`env`、`pwd`、`exit`）の実装
* 入出力リダイレクト（`<`、`>`、`>>`、`<<`）の処理
* パイプライン（`|`）の処理
* 環境変数展開と特殊パラメータ展開（`$?`）
* シグナル（Ctrl-C、Ctrl-D、Ctrl-\）処理



## 機能

* **対話型プロンプト**

  * `minishell$ ` のプロンプトを表示し、GNU Readline ライブラリによるコマンド履歴をサポート。
* **トークン化 & パース**

  * 入力文字列を空白・予約語文字（`|`、`<`、`>`）で分割し、単語と予約語を区別。
  * シングルクォート (`'…'`) とダブルクォート (`"…"`）に対応し、クォート内の文字を一つの単語として扱う。
* **環境変数管理**

  * 起動時に親プロセスの `envp` から連結リスト形式の内部環境変数リスト（`KEY=VALUE`）を構築。
  * ビルトイン `export`、`unset`、`env` で操作可能。
* **ビルトインコマンド**

  * `echo`（`-n` オプション含む）
  * `cd`（`PWD`、`OLDPWD` の更新）
  * `pwd`
  * `export`（`KEY=VALUE`、`KEY+=VALUE` の追加・更新）
  * `unset`（指定キーの削除）
  * `env`（現在の環境一覧を表示）
  * `exit`（ステータス指定も可能）
* **外部コマンド実行**

  * コマンドが `/` または `./` で始まる場合はそのまま `execve`。
  * それ以外は内部環境リストの `PATH` を分割し、順番に `access(…, X_OK)` を確認して `execve`。
  * コマンド未検出・パーミッションエラーは適切にエラーメッセージを出力。
* **リダイレクト**

  * `< file`：入力リダイレクト（読み取り専用）
  * `> file`：出力リダイレクト（書き込み・新規作成または上書き、モード `0644`）
  * `>> file`：出力追加リダイレクト（追記、モード `0644`）
  * `<< DELIM`（ヒアドキュメント）：`DELIM` が単独で現れるまで標準入力を読み取り、パイプ経由で子プロセスに渡す。
* **パイプライン**

  * `cmd1 [args] | cmd2 [args] | … | cmdN [args]` の形式で、各コマンド間を `pipe()` でつなぎ、子プロセスとして順次実行。
  * 最後のコマンドの終了ステータスを `$?` に格納。
* **環境変数展開**

  * `$VAR`：内部環境リストから `VAR` の値を取得して展開。
  * シングルクォート内では展開せず、ダブルクォート内では展開を行う。
  * `$?`：直前に実行したフォアグラウンドパイプラインの終了ステータスを展開。
* **シグナル処理**

  * **対話型時**

    * **Ctrl-C (SIGINT)**：現在の入力行をキャンセルし、新しいプロンプトを改行付きで表示（シェル自体は終了しない）。
    * **Ctrl-D (EOF)**：`readline()` が `NULL` を返すとき、`exit` と表示してシェルを終了。
    * **Ctrl-\ (SIGQUIT)**：無視。
  * **子プロセス実行時**

    * デフォルトハンドラを復帰させ、Ctrl-C／Ctrl-\ を子プロセスに伝搬。必要に応じて子プロセスは終了し、メッセージを出力。
    * シグナルによる終了時は、親シェル側で `(128 + シグナル番号)` を `$?` に設定。



## 動作環境・前提条件

* Unix 系 OS（Linux または macOS）
* C コンパイラ（`gcc` または POSIX 準拠の `cc`）
* GNU Readline ライブラリ：`readline/readline.h` と `-lreadline` リンクオプションが必要



## インストール方法

1. リポジトリをクローンまたはファイル一式を配置（ディレクトリ名は `minishell` 推奨）：

   ```bash
   git clone https://github.com/acta0724/minishell.git
   cd minishell
   ```

2. **ビルド**
   プロジェクトルートにある Makefile を実行すると、

   * `libft/` 内のライブラリ（`libft.a`）をビルド
   * `src/` 以下の全 C ソースをコンパイルして `minishell` バイナリを生成

   ```bash
   make
   ```

3. **クリーンアップ**

   ```bash
   make clean    # オブジェクトファイル (.o) を削除
   make fclean   # オブジェクトファイルと libft.a、minishell バイナリを削除
   make re       # fclean の後に再ビルド
   ```

ビルドが成功すると、プロジェクトルートに `minishell` 実行ファイルが生成されます。



## 使い方

```bash
./minishell
```

と実行すると、以下のようなプロンプトが表示されます：

```
minishell$
```

* **外部コマンド例**

  ```bash
  minishell$ ls -l | grep ".c" > results.txt
  ```
* **ビルトイン例**

  ```bash
  minishell$ export PATH="/usr/local/bin:$PATH"
  minishell$ cd ../
  minishell$ echo Hello World
  minishell$ unset HOME
  minishell$ pwd
  minishell$ env
  minishell$ exit 0
  ```
* **リダイレクト & パイプライン例**

  ```bash
  minishell$ cat < input.txt | grep foo >> output.log
  ```

矢印キーでコマンド履歴を上下に移動し、Enter キーで実行。
`Ctrl-D` を押すと `exit` と表示された後にシェルを終了します。



## 組み込みコマンド

1. **echo**

   ```bash
   echo [-n] [文字列 ...]
   ```

   * 指定された文字列を空白区切りで表示し、デフォルトで改行を付与。
   * `-n` オプションがあると改行を抑制。
   * 複数の `n`（例：`-nn`）も Bash と同様に解釈。

2. **cd**

   ```bash
   cd [ディレクトリ]
   ```

   * カレントディレクトリを `ディレクトリ` に変更。
   * 引数を省略すると `$HOME` に移動。
   * 移動前のディレクトリを `OLDPWD`、移動後を `PWD` にそれぞれ更新。
   * 引数が多すぎる場合や存在しないディレクトリの場合はエラーメッセージを出力：

     ```
     bash: cd: too many arguments
     bash: cd: /path/to/dir: No such file or directory
     ```

3. **pwd**

   ```bash
   pwd
   ```

   * カレントディレクトリのパスを表示し、改行。

4. **export**

   ```bash
   export [NAME=VALUE ...]
   ```

   * 引数なしなら現在の環境変数を以下の形式で表示：

     ```
     declare -x KEY="VALUE"
     ```
   * `NAME=VALUE` の形式で環境に新規追加または更新。
   * `NAME+=VALUE` の形式で値を追記。
   * 無効な変数名の場合はエラー：

     ```
     export: '123ABC': not a valid identifier
     ```

5. **unset**

   ```bash
   unset [NAME ...]
   ```

   * 指定した変数 `NAME` を環境リストから削除。

6. **env**

   ```bash
   env
   ```

   * 現在登録されている環境変数を `KEY=VALUE` 形式で表示（`VALUE` が NULL でないもののみ）。

7. **exit**

   ```bash
   exit [ステータス]
   ```

   * `exit` と表示した後にシェルを終了。
   * 数値が指定されていればその数値 `% 256` を終了ステータスとして使用。
   * 引数が数値でない場合は：

     ```
     bash: exit: abc: numeric argument required
     ```

     と出力してステータス `2` を返して終了。
   * 引数が 2 つ以上の場合は：

     ```
     bash: exit: too many arguments
     ```

     と出力し、終了せずにステータス `1` を返す。



## リダイレクトとパイプライン

1. **入力リダイレクト (`<`)**

   ```bash
   コマンド < 入力ファイル
   ```

   * `入力ファイル` を `O_RDONLY` で開き、標準入力をそのファイルに差し替える。
   * ファイルが存在しない、またはアクセス権限がない場合はエラーを出力して失敗。

2. **出力リダイレクト (`>`)**

   ```bash
   コマンド > 出力ファイル
   ```

   * `出力ファイル` を `O_WRONLY | O_CREAT | O_TRUNC`、モード `0644` で開き、標準出力をそのファイルに差し替え。
   * ファイルが存在しアクセス許可がない場合は：

     ```
     bash: 出力ファイル: Permission denied
     ```

     と出力し、`/dev/null` にリダイレクト。

3. **追記リダイレクト (`>>`)**

   ```bash
   コマンド >> 出力ファイル
   ```

   * `出力ファイル` を `O_WRONLY | O_CREAT | O_APPEND`、モード `0644` で開き、既存ファイルの末尾に追記。
   * パーミッションエラー時はエラーメッセージを出力して失敗。

4. **ヒアドキュメント (`<<`)**

   ```bash
   コマンド << 区切り文字
   ```

   * 標準入力を読み取り、行が `区切り文字` と一致するまで繰り返す。
   * 入力された行はすべて一時的にパイプに書き込み、子プロセスに渡される。
   * ファイルに記録せず、履歴にも残さない。
   * EOF が先に来た場合は警告を表示：

     ```
     bash: warning: here-document at line N delimited by end-of-file (wanted `区切り文字')
     ```

5. **パイプライン (`|`)**

   ```bash
   cmd1 [args] | cmd2 [args] | … | cmdN [args]
   ```

   * `cmd1` 標準出力 → `cmd2` 標準入力 → … → `cmdN` 標準入力 の順に、`pipe()` でパイプを作成し、子プロセスとして実行。
   * 最後のコマンドの終了ステータスを `$?` に格納。



## 環境変数展開

* `$VAR`：内部連結リストから `VAR` が存在すればその値を展開。存在しなければ空文字列。
* **シングルクォート** (`'…'`) 内では展開せず、そのまま文字列として扱う。
* **ダブルクォート** (`"…"`）内では `$VAR` 展開を行う。
* `$?`：直前に実行したフォアグラウンドパイプラインの終了ステータスを展開。
* 例：

  ```bash
  minishell$ export USER=alice
  minishell$ echo "Hello, $USER"
  Hello, alice
  minishell$ echo '$USER'
  $USER
  minishell$ ls nonexistent
  bash: ls: No such file or directory
  minishell$ echo $?
  2
  ```



## シグナル処理の仕様

1. **対話型プロンプト時**

   * **Ctrl-C (SIGINT)**

     * 現在入力中の行をキャンセルし、改行後に新しい `minishell$ ` プロンプトを表示。
     * シグナル発生時にグローバル変数 `g_signal = 130` をセットし、シェルの終了ステータスに反映。
   * **Ctrl-D (EOF)**

     * `readline()` が `NULL` を返すとき、`exit` と表示してシェルを終了。
   * **Ctrl-\ (SIGQUIT)**

     * 無視。

2. **子プロセス実行時**

   * 子プロセス側ではデフォルトシグナルハンドラに戻すため、Ctrl-C／Ctrl-\ を子プロセスに伝搬。必要に応じて子プロセスは終了し、メッセージを出力。
   * シグナルによる終了時は、親シェル側で `(128 + シグナル番号)` を `$?` に設定。
